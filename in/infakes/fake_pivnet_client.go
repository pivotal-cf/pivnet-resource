// Code generated by counterfeiter. DO NOT EDIT.
package infakes

import (
	"sync"

	pivnet "github.com/pivotal-cf/go-pivnet/v7"
)

type FakePivnetClient struct {
	AcceptEULAStub        func(string, int) error
	acceptEULAMutex       sync.RWMutex
	acceptEULAArgsForCall []struct {
		arg1 string
		arg2 int
	}
	acceptEULAReturns struct {
		result1 error
	}
	acceptEULAReturnsOnCall map[int]struct {
		result1 error
	}
	ArtifactReferencesForReleaseStub        func(string, int) ([]pivnet.ArtifactReference, error)
	artifactReferencesForReleaseMutex       sync.RWMutex
	artifactReferencesForReleaseArgsForCall []struct {
		arg1 string
		arg2 int
	}
	artifactReferencesForReleaseReturns struct {
		result1 []pivnet.ArtifactReference
		result2 error
	}
	artifactReferencesForReleaseReturnsOnCall map[int]struct {
		result1 []pivnet.ArtifactReference
		result2 error
	}
	DependencySpecifiersStub        func(string, int) ([]pivnet.DependencySpecifier, error)
	dependencySpecifiersMutex       sync.RWMutex
	dependencySpecifiersArgsForCall []struct {
		arg1 string
		arg2 int
	}
	dependencySpecifiersReturns struct {
		result1 []pivnet.DependencySpecifier
		result2 error
	}
	dependencySpecifiersReturnsOnCall map[int]struct {
		result1 []pivnet.DependencySpecifier
		result2 error
	}
	FileGroupsForReleaseStub        func(string, int) ([]pivnet.FileGroup, error)
	fileGroupsForReleaseMutex       sync.RWMutex
	fileGroupsForReleaseArgsForCall []struct {
		arg1 string
		arg2 int
	}
	fileGroupsForReleaseReturns struct {
		result1 []pivnet.FileGroup
		result2 error
	}
	fileGroupsForReleaseReturnsOnCall map[int]struct {
		result1 []pivnet.FileGroup
		result2 error
	}
	GetReleaseStub        func(string, string) (pivnet.Release, error)
	getReleaseMutex       sync.RWMutex
	getReleaseArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getReleaseReturns struct {
		result1 pivnet.Release
		result2 error
	}
	getReleaseReturnsOnCall map[int]struct {
		result1 pivnet.Release
		result2 error
	}
	ProductFileForReleaseStub        func(string, int, int) (pivnet.ProductFile, error)
	productFileForReleaseMutex       sync.RWMutex
	productFileForReleaseArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	productFileForReleaseReturns struct {
		result1 pivnet.ProductFile
		result2 error
	}
	productFileForReleaseReturnsOnCall map[int]struct {
		result1 pivnet.ProductFile
		result2 error
	}
	ProductFilesForReleaseStub        func(string, int) ([]pivnet.ProductFile, error)
	productFilesForReleaseMutex       sync.RWMutex
	productFilesForReleaseArgsForCall []struct {
		arg1 string
		arg2 int
	}
	productFilesForReleaseReturns struct {
		result1 []pivnet.ProductFile
		result2 error
	}
	productFilesForReleaseReturnsOnCall map[int]struct {
		result1 []pivnet.ProductFile
		result2 error
	}
	ReleaseDependenciesStub        func(string, int) ([]pivnet.ReleaseDependency, error)
	releaseDependenciesMutex       sync.RWMutex
	releaseDependenciesArgsForCall []struct {
		arg1 string
		arg2 int
	}
	releaseDependenciesReturns struct {
		result1 []pivnet.ReleaseDependency
		result2 error
	}
	releaseDependenciesReturnsOnCall map[int]struct {
		result1 []pivnet.ReleaseDependency
		result2 error
	}
	ReleaseUpgradePathsStub        func(string, int) ([]pivnet.ReleaseUpgradePath, error)
	releaseUpgradePathsMutex       sync.RWMutex
	releaseUpgradePathsArgsForCall []struct {
		arg1 string
		arg2 int
	}
	releaseUpgradePathsReturns struct {
		result1 []pivnet.ReleaseUpgradePath
		result2 error
	}
	releaseUpgradePathsReturnsOnCall map[int]struct {
		result1 []pivnet.ReleaseUpgradePath
		result2 error
	}
	UpgradePathSpecifiersStub        func(string, int) ([]pivnet.UpgradePathSpecifier, error)
	upgradePathSpecifiersMutex       sync.RWMutex
	upgradePathSpecifiersArgsForCall []struct {
		arg1 string
		arg2 int
	}
	upgradePathSpecifiersReturns struct {
		result1 []pivnet.UpgradePathSpecifier
		result2 error
	}
	upgradePathSpecifiersReturnsOnCall map[int]struct {
		result1 []pivnet.UpgradePathSpecifier
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePivnetClient) AcceptEULA(arg1 string, arg2 int) error {
	fake.acceptEULAMutex.Lock()
	ret, specificReturn := fake.acceptEULAReturnsOnCall[len(fake.acceptEULAArgsForCall)]
	fake.acceptEULAArgsForCall = append(fake.acceptEULAArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.AcceptEULAStub
	fakeReturns := fake.acceptEULAReturns
	fake.recordInvocation("AcceptEULA", []interface{}{arg1, arg2})
	fake.acceptEULAMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePivnetClient) AcceptEULACallCount() int {
	fake.acceptEULAMutex.RLock()
	defer fake.acceptEULAMutex.RUnlock()
	return len(fake.acceptEULAArgsForCall)
}

func (fake *FakePivnetClient) AcceptEULACalls(stub func(string, int) error) {
	fake.acceptEULAMutex.Lock()
	defer fake.acceptEULAMutex.Unlock()
	fake.AcceptEULAStub = stub
}

func (fake *FakePivnetClient) AcceptEULAArgsForCall(i int) (string, int) {
	fake.acceptEULAMutex.RLock()
	defer fake.acceptEULAMutex.RUnlock()
	argsForCall := fake.acceptEULAArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) AcceptEULAReturns(result1 error) {
	fake.acceptEULAMutex.Lock()
	defer fake.acceptEULAMutex.Unlock()
	fake.AcceptEULAStub = nil
	fake.acceptEULAReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AcceptEULAReturnsOnCall(i int, result1 error) {
	fake.acceptEULAMutex.Lock()
	defer fake.acceptEULAMutex.Unlock()
	fake.AcceptEULAStub = nil
	if fake.acceptEULAReturnsOnCall == nil {
		fake.acceptEULAReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.acceptEULAReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) ArtifactReferencesForRelease(arg1 string, arg2 int) ([]pivnet.ArtifactReference, error) {
	fake.artifactReferencesForReleaseMutex.Lock()
	ret, specificReturn := fake.artifactReferencesForReleaseReturnsOnCall[len(fake.artifactReferencesForReleaseArgsForCall)]
	fake.artifactReferencesForReleaseArgsForCall = append(fake.artifactReferencesForReleaseArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.ArtifactReferencesForReleaseStub
	fakeReturns := fake.artifactReferencesForReleaseReturns
	fake.recordInvocation("ArtifactReferencesForRelease", []interface{}{arg1, arg2})
	fake.artifactReferencesForReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ArtifactReferencesForReleaseCallCount() int {
	fake.artifactReferencesForReleaseMutex.RLock()
	defer fake.artifactReferencesForReleaseMutex.RUnlock()
	return len(fake.artifactReferencesForReleaseArgsForCall)
}

func (fake *FakePivnetClient) ArtifactReferencesForReleaseCalls(stub func(string, int) ([]pivnet.ArtifactReference, error)) {
	fake.artifactReferencesForReleaseMutex.Lock()
	defer fake.artifactReferencesForReleaseMutex.Unlock()
	fake.ArtifactReferencesForReleaseStub = stub
}

func (fake *FakePivnetClient) ArtifactReferencesForReleaseArgsForCall(i int) (string, int) {
	fake.artifactReferencesForReleaseMutex.RLock()
	defer fake.artifactReferencesForReleaseMutex.RUnlock()
	argsForCall := fake.artifactReferencesForReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) ArtifactReferencesForReleaseReturns(result1 []pivnet.ArtifactReference, result2 error) {
	fake.artifactReferencesForReleaseMutex.Lock()
	defer fake.artifactReferencesForReleaseMutex.Unlock()
	fake.ArtifactReferencesForReleaseStub = nil
	fake.artifactReferencesForReleaseReturns = struct {
		result1 []pivnet.ArtifactReference
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ArtifactReferencesForReleaseReturnsOnCall(i int, result1 []pivnet.ArtifactReference, result2 error) {
	fake.artifactReferencesForReleaseMutex.Lock()
	defer fake.artifactReferencesForReleaseMutex.Unlock()
	fake.ArtifactReferencesForReleaseStub = nil
	if fake.artifactReferencesForReleaseReturnsOnCall == nil {
		fake.artifactReferencesForReleaseReturnsOnCall = make(map[int]struct {
			result1 []pivnet.ArtifactReference
			result2 error
		})
	}
	fake.artifactReferencesForReleaseReturnsOnCall[i] = struct {
		result1 []pivnet.ArtifactReference
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DependencySpecifiers(arg1 string, arg2 int) ([]pivnet.DependencySpecifier, error) {
	fake.dependencySpecifiersMutex.Lock()
	ret, specificReturn := fake.dependencySpecifiersReturnsOnCall[len(fake.dependencySpecifiersArgsForCall)]
	fake.dependencySpecifiersArgsForCall = append(fake.dependencySpecifiersArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.DependencySpecifiersStub
	fakeReturns := fake.dependencySpecifiersReturns
	fake.recordInvocation("DependencySpecifiers", []interface{}{arg1, arg2})
	fake.dependencySpecifiersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) DependencySpecifiersCallCount() int {
	fake.dependencySpecifiersMutex.RLock()
	defer fake.dependencySpecifiersMutex.RUnlock()
	return len(fake.dependencySpecifiersArgsForCall)
}

func (fake *FakePivnetClient) DependencySpecifiersCalls(stub func(string, int) ([]pivnet.DependencySpecifier, error)) {
	fake.dependencySpecifiersMutex.Lock()
	defer fake.dependencySpecifiersMutex.Unlock()
	fake.DependencySpecifiersStub = stub
}

func (fake *FakePivnetClient) DependencySpecifiersArgsForCall(i int) (string, int) {
	fake.dependencySpecifiersMutex.RLock()
	defer fake.dependencySpecifiersMutex.RUnlock()
	argsForCall := fake.dependencySpecifiersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) DependencySpecifiersReturns(result1 []pivnet.DependencySpecifier, result2 error) {
	fake.dependencySpecifiersMutex.Lock()
	defer fake.dependencySpecifiersMutex.Unlock()
	fake.DependencySpecifiersStub = nil
	fake.dependencySpecifiersReturns = struct {
		result1 []pivnet.DependencySpecifier
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DependencySpecifiersReturnsOnCall(i int, result1 []pivnet.DependencySpecifier, result2 error) {
	fake.dependencySpecifiersMutex.Lock()
	defer fake.dependencySpecifiersMutex.Unlock()
	fake.DependencySpecifiersStub = nil
	if fake.dependencySpecifiersReturnsOnCall == nil {
		fake.dependencySpecifiersReturnsOnCall = make(map[int]struct {
			result1 []pivnet.DependencySpecifier
			result2 error
		})
	}
	fake.dependencySpecifiersReturnsOnCall[i] = struct {
		result1 []pivnet.DependencySpecifier
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroupsForRelease(arg1 string, arg2 int) ([]pivnet.FileGroup, error) {
	fake.fileGroupsForReleaseMutex.Lock()
	ret, specificReturn := fake.fileGroupsForReleaseReturnsOnCall[len(fake.fileGroupsForReleaseArgsForCall)]
	fake.fileGroupsForReleaseArgsForCall = append(fake.fileGroupsForReleaseArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.FileGroupsForReleaseStub
	fakeReturns := fake.fileGroupsForReleaseReturns
	fake.recordInvocation("FileGroupsForRelease", []interface{}{arg1, arg2})
	fake.fileGroupsForReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) FileGroupsForReleaseCallCount() int {
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	return len(fake.fileGroupsForReleaseArgsForCall)
}

func (fake *FakePivnetClient) FileGroupsForReleaseCalls(stub func(string, int) ([]pivnet.FileGroup, error)) {
	fake.fileGroupsForReleaseMutex.Lock()
	defer fake.fileGroupsForReleaseMutex.Unlock()
	fake.FileGroupsForReleaseStub = stub
}

func (fake *FakePivnetClient) FileGroupsForReleaseArgsForCall(i int) (string, int) {
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	argsForCall := fake.fileGroupsForReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) FileGroupsForReleaseReturns(result1 []pivnet.FileGroup, result2 error) {
	fake.fileGroupsForReleaseMutex.Lock()
	defer fake.fileGroupsForReleaseMutex.Unlock()
	fake.FileGroupsForReleaseStub = nil
	fake.fileGroupsForReleaseReturns = struct {
		result1 []pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) FileGroupsForReleaseReturnsOnCall(i int, result1 []pivnet.FileGroup, result2 error) {
	fake.fileGroupsForReleaseMutex.Lock()
	defer fake.fileGroupsForReleaseMutex.Unlock()
	fake.FileGroupsForReleaseStub = nil
	if fake.fileGroupsForReleaseReturnsOnCall == nil {
		fake.fileGroupsForReleaseReturnsOnCall = make(map[int]struct {
			result1 []pivnet.FileGroup
			result2 error
		})
	}
	fake.fileGroupsForReleaseReturnsOnCall[i] = struct {
		result1 []pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) GetRelease(arg1 string, arg2 string) (pivnet.Release, error) {
	fake.getReleaseMutex.Lock()
	ret, specificReturn := fake.getReleaseReturnsOnCall[len(fake.getReleaseArgsForCall)]
	fake.getReleaseArgsForCall = append(fake.getReleaseArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetReleaseStub
	fakeReturns := fake.getReleaseReturns
	fake.recordInvocation("GetRelease", []interface{}{arg1, arg2})
	fake.getReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) GetReleaseCallCount() int {
	fake.getReleaseMutex.RLock()
	defer fake.getReleaseMutex.RUnlock()
	return len(fake.getReleaseArgsForCall)
}

func (fake *FakePivnetClient) GetReleaseCalls(stub func(string, string) (pivnet.Release, error)) {
	fake.getReleaseMutex.Lock()
	defer fake.getReleaseMutex.Unlock()
	fake.GetReleaseStub = stub
}

func (fake *FakePivnetClient) GetReleaseArgsForCall(i int) (string, string) {
	fake.getReleaseMutex.RLock()
	defer fake.getReleaseMutex.RUnlock()
	argsForCall := fake.getReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) GetReleaseReturns(result1 pivnet.Release, result2 error) {
	fake.getReleaseMutex.Lock()
	defer fake.getReleaseMutex.Unlock()
	fake.GetReleaseStub = nil
	fake.getReleaseReturns = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) GetReleaseReturnsOnCall(i int, result1 pivnet.Release, result2 error) {
	fake.getReleaseMutex.Lock()
	defer fake.getReleaseMutex.Unlock()
	fake.GetReleaseStub = nil
	if fake.getReleaseReturnsOnCall == nil {
		fake.getReleaseReturnsOnCall = make(map[int]struct {
			result1 pivnet.Release
			result2 error
		})
	}
	fake.getReleaseReturnsOnCall[i] = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ProductFileForRelease(arg1 string, arg2 int, arg3 int) (pivnet.ProductFile, error) {
	fake.productFileForReleaseMutex.Lock()
	ret, specificReturn := fake.productFileForReleaseReturnsOnCall[len(fake.productFileForReleaseArgsForCall)]
	fake.productFileForReleaseArgsForCall = append(fake.productFileForReleaseArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ProductFileForReleaseStub
	fakeReturns := fake.productFileForReleaseReturns
	fake.recordInvocation("ProductFileForRelease", []interface{}{arg1, arg2, arg3})
	fake.productFileForReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ProductFileForReleaseCallCount() int {
	fake.productFileForReleaseMutex.RLock()
	defer fake.productFileForReleaseMutex.RUnlock()
	return len(fake.productFileForReleaseArgsForCall)
}

func (fake *FakePivnetClient) ProductFileForReleaseCalls(stub func(string, int, int) (pivnet.ProductFile, error)) {
	fake.productFileForReleaseMutex.Lock()
	defer fake.productFileForReleaseMutex.Unlock()
	fake.ProductFileForReleaseStub = stub
}

func (fake *FakePivnetClient) ProductFileForReleaseArgsForCall(i int) (string, int, int) {
	fake.productFileForReleaseMutex.RLock()
	defer fake.productFileForReleaseMutex.RUnlock()
	argsForCall := fake.productFileForReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) ProductFileForReleaseReturns(result1 pivnet.ProductFile, result2 error) {
	fake.productFileForReleaseMutex.Lock()
	defer fake.productFileForReleaseMutex.Unlock()
	fake.ProductFileForReleaseStub = nil
	fake.productFileForReleaseReturns = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ProductFileForReleaseReturnsOnCall(i int, result1 pivnet.ProductFile, result2 error) {
	fake.productFileForReleaseMutex.Lock()
	defer fake.productFileForReleaseMutex.Unlock()
	fake.ProductFileForReleaseStub = nil
	if fake.productFileForReleaseReturnsOnCall == nil {
		fake.productFileForReleaseReturnsOnCall = make(map[int]struct {
			result1 pivnet.ProductFile
			result2 error
		})
	}
	fake.productFileForReleaseReturnsOnCall[i] = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ProductFilesForRelease(arg1 string, arg2 int) ([]pivnet.ProductFile, error) {
	fake.productFilesForReleaseMutex.Lock()
	ret, specificReturn := fake.productFilesForReleaseReturnsOnCall[len(fake.productFilesForReleaseArgsForCall)]
	fake.productFilesForReleaseArgsForCall = append(fake.productFilesForReleaseArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.ProductFilesForReleaseStub
	fakeReturns := fake.productFilesForReleaseReturns
	fake.recordInvocation("ProductFilesForRelease", []interface{}{arg1, arg2})
	fake.productFilesForReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ProductFilesForReleaseCallCount() int {
	fake.productFilesForReleaseMutex.RLock()
	defer fake.productFilesForReleaseMutex.RUnlock()
	return len(fake.productFilesForReleaseArgsForCall)
}

func (fake *FakePivnetClient) ProductFilesForReleaseCalls(stub func(string, int) ([]pivnet.ProductFile, error)) {
	fake.productFilesForReleaseMutex.Lock()
	defer fake.productFilesForReleaseMutex.Unlock()
	fake.ProductFilesForReleaseStub = stub
}

func (fake *FakePivnetClient) ProductFilesForReleaseArgsForCall(i int) (string, int) {
	fake.productFilesForReleaseMutex.RLock()
	defer fake.productFilesForReleaseMutex.RUnlock()
	argsForCall := fake.productFilesForReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) ProductFilesForReleaseReturns(result1 []pivnet.ProductFile, result2 error) {
	fake.productFilesForReleaseMutex.Lock()
	defer fake.productFilesForReleaseMutex.Unlock()
	fake.ProductFilesForReleaseStub = nil
	fake.productFilesForReleaseReturns = struct {
		result1 []pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ProductFilesForReleaseReturnsOnCall(i int, result1 []pivnet.ProductFile, result2 error) {
	fake.productFilesForReleaseMutex.Lock()
	defer fake.productFilesForReleaseMutex.Unlock()
	fake.ProductFilesForReleaseStub = nil
	if fake.productFilesForReleaseReturnsOnCall == nil {
		fake.productFilesForReleaseReturnsOnCall = make(map[int]struct {
			result1 []pivnet.ProductFile
			result2 error
		})
	}
	fake.productFilesForReleaseReturnsOnCall[i] = struct {
		result1 []pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ReleaseDependencies(arg1 string, arg2 int) ([]pivnet.ReleaseDependency, error) {
	fake.releaseDependenciesMutex.Lock()
	ret, specificReturn := fake.releaseDependenciesReturnsOnCall[len(fake.releaseDependenciesArgsForCall)]
	fake.releaseDependenciesArgsForCall = append(fake.releaseDependenciesArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.ReleaseDependenciesStub
	fakeReturns := fake.releaseDependenciesReturns
	fake.recordInvocation("ReleaseDependencies", []interface{}{arg1, arg2})
	fake.releaseDependenciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ReleaseDependenciesCallCount() int {
	fake.releaseDependenciesMutex.RLock()
	defer fake.releaseDependenciesMutex.RUnlock()
	return len(fake.releaseDependenciesArgsForCall)
}

func (fake *FakePivnetClient) ReleaseDependenciesCalls(stub func(string, int) ([]pivnet.ReleaseDependency, error)) {
	fake.releaseDependenciesMutex.Lock()
	defer fake.releaseDependenciesMutex.Unlock()
	fake.ReleaseDependenciesStub = stub
}

func (fake *FakePivnetClient) ReleaseDependenciesArgsForCall(i int) (string, int) {
	fake.releaseDependenciesMutex.RLock()
	defer fake.releaseDependenciesMutex.RUnlock()
	argsForCall := fake.releaseDependenciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) ReleaseDependenciesReturns(result1 []pivnet.ReleaseDependency, result2 error) {
	fake.releaseDependenciesMutex.Lock()
	defer fake.releaseDependenciesMutex.Unlock()
	fake.ReleaseDependenciesStub = nil
	fake.releaseDependenciesReturns = struct {
		result1 []pivnet.ReleaseDependency
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ReleaseDependenciesReturnsOnCall(i int, result1 []pivnet.ReleaseDependency, result2 error) {
	fake.releaseDependenciesMutex.Lock()
	defer fake.releaseDependenciesMutex.Unlock()
	fake.ReleaseDependenciesStub = nil
	if fake.releaseDependenciesReturnsOnCall == nil {
		fake.releaseDependenciesReturnsOnCall = make(map[int]struct {
			result1 []pivnet.ReleaseDependency
			result2 error
		})
	}
	fake.releaseDependenciesReturnsOnCall[i] = struct {
		result1 []pivnet.ReleaseDependency
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ReleaseUpgradePaths(arg1 string, arg2 int) ([]pivnet.ReleaseUpgradePath, error) {
	fake.releaseUpgradePathsMutex.Lock()
	ret, specificReturn := fake.releaseUpgradePathsReturnsOnCall[len(fake.releaseUpgradePathsArgsForCall)]
	fake.releaseUpgradePathsArgsForCall = append(fake.releaseUpgradePathsArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.ReleaseUpgradePathsStub
	fakeReturns := fake.releaseUpgradePathsReturns
	fake.recordInvocation("ReleaseUpgradePaths", []interface{}{arg1, arg2})
	fake.releaseUpgradePathsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) ReleaseUpgradePathsCallCount() int {
	fake.releaseUpgradePathsMutex.RLock()
	defer fake.releaseUpgradePathsMutex.RUnlock()
	return len(fake.releaseUpgradePathsArgsForCall)
}

func (fake *FakePivnetClient) ReleaseUpgradePathsCalls(stub func(string, int) ([]pivnet.ReleaseUpgradePath, error)) {
	fake.releaseUpgradePathsMutex.Lock()
	defer fake.releaseUpgradePathsMutex.Unlock()
	fake.ReleaseUpgradePathsStub = stub
}

func (fake *FakePivnetClient) ReleaseUpgradePathsArgsForCall(i int) (string, int) {
	fake.releaseUpgradePathsMutex.RLock()
	defer fake.releaseUpgradePathsMutex.RUnlock()
	argsForCall := fake.releaseUpgradePathsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) ReleaseUpgradePathsReturns(result1 []pivnet.ReleaseUpgradePath, result2 error) {
	fake.releaseUpgradePathsMutex.Lock()
	defer fake.releaseUpgradePathsMutex.Unlock()
	fake.ReleaseUpgradePathsStub = nil
	fake.releaseUpgradePathsReturns = struct {
		result1 []pivnet.ReleaseUpgradePath
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) ReleaseUpgradePathsReturnsOnCall(i int, result1 []pivnet.ReleaseUpgradePath, result2 error) {
	fake.releaseUpgradePathsMutex.Lock()
	defer fake.releaseUpgradePathsMutex.Unlock()
	fake.ReleaseUpgradePathsStub = nil
	if fake.releaseUpgradePathsReturnsOnCall == nil {
		fake.releaseUpgradePathsReturnsOnCall = make(map[int]struct {
			result1 []pivnet.ReleaseUpgradePath
			result2 error
		})
	}
	fake.releaseUpgradePathsReturnsOnCall[i] = struct {
		result1 []pivnet.ReleaseUpgradePath
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UpgradePathSpecifiers(arg1 string, arg2 int) ([]pivnet.UpgradePathSpecifier, error) {
	fake.upgradePathSpecifiersMutex.Lock()
	ret, specificReturn := fake.upgradePathSpecifiersReturnsOnCall[len(fake.upgradePathSpecifiersArgsForCall)]
	fake.upgradePathSpecifiersArgsForCall = append(fake.upgradePathSpecifiersArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.UpgradePathSpecifiersStub
	fakeReturns := fake.upgradePathSpecifiersReturns
	fake.recordInvocation("UpgradePathSpecifiers", []interface{}{arg1, arg2})
	fake.upgradePathSpecifiersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) UpgradePathSpecifiersCallCount() int {
	fake.upgradePathSpecifiersMutex.RLock()
	defer fake.upgradePathSpecifiersMutex.RUnlock()
	return len(fake.upgradePathSpecifiersArgsForCall)
}

func (fake *FakePivnetClient) UpgradePathSpecifiersCalls(stub func(string, int) ([]pivnet.UpgradePathSpecifier, error)) {
	fake.upgradePathSpecifiersMutex.Lock()
	defer fake.upgradePathSpecifiersMutex.Unlock()
	fake.UpgradePathSpecifiersStub = stub
}

func (fake *FakePivnetClient) UpgradePathSpecifiersArgsForCall(i int) (string, int) {
	fake.upgradePathSpecifiersMutex.RLock()
	defer fake.upgradePathSpecifiersMutex.RUnlock()
	argsForCall := fake.upgradePathSpecifiersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) UpgradePathSpecifiersReturns(result1 []pivnet.UpgradePathSpecifier, result2 error) {
	fake.upgradePathSpecifiersMutex.Lock()
	defer fake.upgradePathSpecifiersMutex.Unlock()
	fake.UpgradePathSpecifiersStub = nil
	fake.upgradePathSpecifiersReturns = struct {
		result1 []pivnet.UpgradePathSpecifier
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UpgradePathSpecifiersReturnsOnCall(i int, result1 []pivnet.UpgradePathSpecifier, result2 error) {
	fake.upgradePathSpecifiersMutex.Lock()
	defer fake.upgradePathSpecifiersMutex.Unlock()
	fake.UpgradePathSpecifiersStub = nil
	if fake.upgradePathSpecifiersReturnsOnCall == nil {
		fake.upgradePathSpecifiersReturnsOnCall = make(map[int]struct {
			result1 []pivnet.UpgradePathSpecifier
			result2 error
		})
	}
	fake.upgradePathSpecifiersReturnsOnCall[i] = struct {
		result1 []pivnet.UpgradePathSpecifier
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acceptEULAMutex.RLock()
	defer fake.acceptEULAMutex.RUnlock()
	fake.artifactReferencesForReleaseMutex.RLock()
	defer fake.artifactReferencesForReleaseMutex.RUnlock()
	fake.dependencySpecifiersMutex.RLock()
	defer fake.dependencySpecifiersMutex.RUnlock()
	fake.fileGroupsForReleaseMutex.RLock()
	defer fake.fileGroupsForReleaseMutex.RUnlock()
	fake.getReleaseMutex.RLock()
	defer fake.getReleaseMutex.RUnlock()
	fake.productFileForReleaseMutex.RLock()
	defer fake.productFileForReleaseMutex.RUnlock()
	fake.productFilesForReleaseMutex.RLock()
	defer fake.productFilesForReleaseMutex.RUnlock()
	fake.releaseDependenciesMutex.RLock()
	defer fake.releaseDependenciesMutex.RUnlock()
	fake.releaseUpgradePathsMutex.RLock()
	defer fake.releaseUpgradePathsMutex.RUnlock()
	fake.upgradePathSpecifiersMutex.RLock()
	defer fake.upgradePathSpecifiersMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePivnetClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
